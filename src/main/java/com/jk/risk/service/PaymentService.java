package com.jk.risk.service;import com.google.common.collect.Lists;import com.google.common.collect.Maps;import com.monitorjbl.xlsx.StreamingReader;import com.rm.domain.AnnualizedRate;import com.rm.domain.Contract;import com.rm.util.exception.ErrorEnum;import com.rm.util.exception.RMSystemException;import org.apache.poi.ss.usermodel.Cell;import org.apache.poi.ss.usermodel.Row;import org.apache.poi.ss.usermodel.Sheet;import org.apache.poi.ss.usermodel.Workbook;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Service;import org.springframework.util.CollectionUtils;import java.io.FileInputStream;import java.time.Instant;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.temporal.ChronoUnit;import java.util.List;import java.util.Map;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.stream.Collectors;import static com.rm.util.CommonUtil.*;import static com.rm.util.Constants.LOW_ANNUALIZED_RATE;import static com.rm.util.Constants.MAX_ANNUALIZED_RATE;//import com.monitorjbl.xlsx.StreamingReader;/** * 还款计划 * User: allen * Date: 2017/11/14 上午9:33 */@Servicepublic class PaymentService {    private final Logger logger = LoggerFactory.getLogger(getClass());    private final ExecutorService service = Executors.newFixedThreadPool(20);    /**     * 年化收益率, 按天计算     * @param contracts 还款计划     * @return 结果     */    private double annualizedRate(List<Contract> contracts, boolean low) {        List<Double> list = low ? rangeIncreaseLow() : rangeIncreaseHigh();        List<Double> ranges = binSearch(contracts, list);        if(CollectionUtils.isEmpty(ranges)) return -1;        if(ranges.size() == 1) return ranges.get(0);        for(double rate : ranges){            if(minus(contracts, rate) >= 0) {                return rate;            }        }        return -1;    }    private double annualizedRate1(List<Contract> contracts) {        Contract ct = contracts.get(0);        double step = 0.0001d;//        List<Double> list = rangeIncrease(LOW_ANNUALIZED_RATE, MAX_ANNUALIZED_RATE, step);//        list = Lists.newArrayList(9.015);        for (double k = LOW_ANNUALIZED_RATE; k <= MAX_ANNUALIZED_RATE; k = doubleAdd(k, step)){            double item = k;            LocalDate firstPayDate =  LocalDateTime.ofInstant(Instant.ofEpochMilli(ct.firstPayDate.getTime()), DEFAULT_ZONE_OFFSET).toLocalDate();            double totalPaidFee = contracts.stream().mapToDouble(e->singleRate(e, item)).sum();            double totalOutCome = ct.firstPayPrice;            double otherThFee = 0d;//第n次打款折现率            if(ct.secondPayDate != null) {                LocalDate secondPayDate =  LocalDateTime.ofInstant(Instant.ofEpochMilli(ct.secondPayDate.getTime()), DEFAULT_ZONE_OFFSET).toLocalDate();                long days = secondPayDate.until(firstPayDate, ChronoUnit.DAYS);                double secondPaidFee = doubleMultiply(ct.secondPayPrice, Math.pow((1 + item/365), days));                otherThFee = doubleAdd(otherThFee, secondPaidFee);            }            if(ct.thirdPayDate != null) {                LocalDate thirdPayDate =  LocalDateTime.ofInstant(Instant.ofEpochMilli(ct.thirdPayDate.getTime()), DEFAULT_ZONE_OFFSET).toLocalDate();                long days = thirdPayDate.until(firstPayDate, ChronoUnit.DAYS);                double thirdPaidFee = doubleMultiply(ct.thirdPayPrice, Math.pow((1 + item/365), days));                otherThFee = doubleAdd(otherThFee, thirdPaidFee);            }            if(ct.fourthPayDate != null) {                LocalDate fourthPayDate =  LocalDateTime.ofInstant(Instant.ofEpochMilli(ct.fourthPayDate.getTime()), DEFAULT_ZONE_OFFSET).toLocalDate();                long days = fourthPayDate.until(firstPayDate, ChronoUnit.DAYS);                double fourthPaidFee = doubleMultiply(ct.fourthPayPrice, Math.pow((1 + item/365), days));                otherThFee = doubleAdd(otherThFee, fourthPaidFee);            }            double totalBreachFee = 0d;            if(ct.breachRefundDate !=  null){                // 违约金贴现率                LocalDate breachRefundDate =  LocalDateTime.ofInstant(Instant.ofEpochMilli(ct.breachRefundDate.getTime()), DEFAULT_ZONE_OFFSET).toLocalDate();                long days = breachRefundDate.until(firstPayDate, ChronoUnit.DAYS);                totalBreachFee = doubleAdd(ct.redundBaseFee, ct.breachServiceFee, ct.breachFee)                        * Math.pow((1 + item/365), days);            }            totalOutCome = doubleAdd(totalOutCome, otherThFee);            double minus = doubleSubtract(totalOutCome, doubleAdd(totalPaidFee, totalBreachFee));            if(minus >= 0) {                return item;            }        }        return -1;    }    /**     * 先找到年化率所在区间     */    private List<Double> binSearch(List<Contract> contracts, List<Double> srcArray) {        int midIndex = srcArray.size() / 2;        if (minus(contracts, srcArray.get(midIndex)) == 0) {            return Lists.newArrayList(srcArray.get(midIndex));        }        AnnualizedRate rate = new AnnualizedRate();        int start = 0;        int end = srcArray.size() - 1;        double low = 0;        double high = 0;        while (start <= end) {            midIndex = (end - start) / 2 + start;            rate.rate = srcArray.get(midIndex);            double minus = minus(contracts, rate.rate);            if (minus < 0) {                rate.left = midIndex;                start = midIndex + 1;                low = minus;            } else if (minus > 0) {                rate.right = midIndex;                end = midIndex - 1;                high = minus;            } else {                return Lists.newArrayList(srcArray.get(midIndex));            }            if(low < 0 && high > 0) {                return srcArray.subList(rate.left, rate.right + 1);            }        }        return Lists.newArrayList();    }    /**     * 公司支出和收入的差值     * @param contracts 合同     * @param item 年化     * @return 差值     */    private double minus(List<Contract> contracts, double item) {        Contract ct = contracts.get(0);        // 公司代交金额        LocalDate firstPayDate =  LocalDateTime.ofInstant(Instant.ofEpochMilli(ct.firstPayDate.getTime()), DEFAULT_ZONE_OFFSET).toLocalDate();        double totalPaidFee = contracts.parallelStream().mapToDouble(e->singleRate(e, item)).sum();        double totalOutCome = ct.firstPayPrice;        double otherThFee = 0d;//第n次打款折现率        if(ct.secondPayDate != null) {            LocalDate secondPayDate =  LocalDateTime.ofInstant(Instant.ofEpochMilli(ct.secondPayDate.getTime()), DEFAULT_ZONE_OFFSET).toLocalDate();            long days = secondPayDate.until(firstPayDate, ChronoUnit.DAYS);            double secondPaidFee = doubleMultiply(ct.secondPayPrice, Math.pow((1 + item/365), days));            otherThFee = doubleAdd(otherThFee, secondPaidFee);        }        if(ct.thirdPayDate != null) {            LocalDate thirdPayDate =  LocalDateTime.ofInstant(Instant.ofEpochMilli(ct.thirdPayDate.getTime()), DEFAULT_ZONE_OFFSET).toLocalDate();            long days = thirdPayDate.until(firstPayDate, ChronoUnit.DAYS);            double thirdPaidFee = doubleMultiply(ct.thirdPayPrice, Math.pow((1 + item/365), days));            otherThFee = doubleAdd(otherThFee, thirdPaidFee);        }        if(ct.fourthPayDate != null) {            LocalDate fourthPayDate =  LocalDateTime.ofInstant(Instant.ofEpochMilli(ct.fourthPayDate.getTime()), DEFAULT_ZONE_OFFSET).toLocalDate();            long days = fourthPayDate.until(firstPayDate, ChronoUnit.DAYS);            double fourthPaidFee = doubleMultiply(ct.fourthPayPrice, Math.pow((1 + item/365), days));            otherThFee = doubleAdd(otherThFee, fourthPaidFee);        }        double totalBreachFee = 0d;        if(ct.breachRefundDate !=  null){            // 违约金贴现率            LocalDate breachRefundDate =  LocalDateTime.ofInstant(Instant.ofEpochMilli(ct.breachRefundDate.getTime()), DEFAULT_ZONE_OFFSET).toLocalDate();            long days = breachRefundDate.until(firstPayDate, ChronoUnit.DAYS);            totalBreachFee = doubleAdd(ct.redundBaseFee, ct.breachServiceFee, ct.breachFee)                    * Math.pow((1 + item/365), days);        }        totalOutCome = doubleAdd(totalOutCome, otherThFee);        return doubleSubtract(totalOutCome, doubleAdd(totalPaidFee, totalBreachFee));    }    /**     * 每一期的还款金额     * @param contract 还款计划     * @param rate 年华收益率, 按天计算     * @return 结果     */    private double singleRate(Contract contract, double rate){        if(contract.payDate == null) return 0;        LocalDate payDate =  LocalDateTime.ofInstant(Instant.ofEpochMilli(contract.payDate.getTime()), DEFAULT_ZONE_OFFSET).toLocalDate();        LocalDate firstPayDate =  LocalDateTime.ofInstant(Instant.ofEpochMilli(contract.firstPayDate.getTime()), DEFAULT_ZONE_OFFSET).toLocalDate();        long days = payDate.until(firstPayDate, ChronoUnit.DAYS);        //计算每一期还款计划的贴现率        double totalPaidFee = doubleAdd(contract.realBasePrice, contract.overDueFine, contract.serviceFee);        double result = totalPaidFee * Math.pow((1 + rate/365), days);        return result;    }    /**     * 根据Excel获取贴现率     * @return 贴现率     */    public Map<String, Double> getRate(java.io.File file/*Workbook workbook*/, boolean low) throws Exception{        List<Contract> contracts = loadExcel(file);//        List<Contract> contracts = processWorkBook(workbook);        Map<String, Double> result = Maps.newConcurrentMap();        Map<String, List<Contract>> map = contracts.stream().collect(Collectors.groupingBy(e->e.contractId));        map.keySet().parallelStream().forEach(e-> result.put(e, annualizedRate(map.get(e), low)));        return result;    }    private List<Contract> loadExcel(java.io.File file) throws Exception{        try (FileInputStream in = new FileInputStream(file)){            Workbook wk = StreamingReader.builder()                    .rowCacheSize(100)      //缓存到内存中的行数，默认是10                    .bufferSize(4096)       //读取资源时，缓存到内存的字节大小，默认是1024                    .open(in);              //打开资源，必须，可以是InputStream或者是File，注意：只能打开XLSX格式的文件            return processWorkBook(wk);        }//        Sheet sheet = wk.getSheetAt(0);//        //遍历所有的行//        for (Row row : sheet) {//            System.out.println("开始遍历第" + row.getRowNum() + "行数据：");//            //遍历所有的列//            for (Cell cell : row) {//                System.out.print(cell.getStringCellValue() + " ");//            }//            System.out.println(" ");//        }//        return null;    }    private List<Contract> processWorkBook(Workbook workbook) {        String errMsg = "天哪，数据居然有错！！哎！";        Sheet sheet = workbook.getSheetAt(0);//        int rowNum = sheet.getLastRowNum();        int i = 0;        List<Contract> contracts = Lists.newArrayList();        for(Row row : sheet) {            if(i == 0) {                i ++;                continue;            }//        for (int i = 1; i <= rowNum; i++){            Contract contract = new Contract();//            Row row = sheet.getRow(i);            Cell cell = row.getCell(0);            contract.contractId = cell.getStringCellValue();            cell = row.getCell(2);            if(cell !=null) contract.breachRefundDate = cell.getDateCellValue();            cell = row.getCell(3);            if(cell !=null) contract.redundBaseFee = cell.getNumericCellValue();            cell = row.getCell(4);            if(cell !=null) contract.breachServiceFee = cell.getNumericCellValue();            cell = row.getCell(5);            if(cell !=null) contract.breachFee = cell.getNumericCellValue();            cell = row.getCell(6);            if(cell == null || cell.getDateCellValue() == null)                throw new RMSystemException(ErrorEnum.FileDataError, errMsg);            contract.firstPayDate = cell.getDateCellValue();            cell = row.getCell(7);            if(cell == null) throw new RMSystemException(ErrorEnum.FileDataError, errMsg);            contract.firstPayPrice = cell.getNumericCellValue();            cell = row.getCell(8);            if(cell !=null) contract.secondPayDate = cell.getDateCellValue();            cell = row.getCell(9);            if(cell !=null) contract.secondPayPrice = cell.getNumericCellValue();            cell = row.getCell(10);            if(cell !=null) contract.thirdPayDate = cell.getDateCellValue();            cell = row.getCell(11);            if(cell !=null) contract.thirdPayPrice = cell.getNumericCellValue();            cell = row.getCell(12);            if(cell !=null) contract.fourthPayDate = cell.getDateCellValue();            cell = row.getCell(13);            if(cell !=null) contract.fourthPayPrice = cell.getNumericCellValue();            cell = row.getCell(16);            if(cell !=null) contract.payDate = cell.getDateCellValue();            cell = row.getCell(17);            if(cell != null) contract.realBasePrice = cell.getNumericCellValue();            cell = row.getCell(18);            if(cell !=null) contract.serviceFee = cell.getNumericCellValue();            cell = row.getCell(19);            if(cell !=null) contract.overDueFine = cell.getNumericCellValue();            contracts.add(contract);        }        return contracts;    }    public static void main(String[] args) {//        ContractProperty c = new ContractProperty();//        c.firstPayPrice = 10000.0;//        c.firstPayDate = LocalDate.of(2016, 1, 1);//////        List<RepayPlan> repayPlanList = Lists.newArrayList();//        for (int i = 1; i < 12; i++){//            RepayPlan rp = new RepayPlan();//            rp.realBasePrice = 500;//            rp.payDate = c.firstPayDate.plusMonths(i);//            repayPlanList.add(rp);//        }//        PaymentService service = new PaymentService();//        double r = service.annualizedRate(c, repayPlanList);//        System.out.println(r);        List<Integer> list = Lists.newArrayList(2,3,4,6,7,9,0);        System.out.println(list.subList(2,list.size()));    }}